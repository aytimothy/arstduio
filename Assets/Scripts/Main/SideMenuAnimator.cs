using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Assertions;

public class SideMenuAnimator : MonoBehaviour {
    public RectTransform sideMenuTransform;
    public RectTransform screenTransform;

    public Vector2 startPosition;   // this is the position when inactive.
    public Vector2 endPosition;     // this is the position when active.
    public float animationDuration = 1f;
    public float animationDelay = 0f;
    public bool hidden;
    public AnimationCurve animationCurve;

    [SerializeField]
    [EditorReadOnly]
    bool _hidden;
    float startTime = float.MaxValue;
    float endTime = float.MaxValue;
    [SerializeField]
    [EditorReadOnly]
    bool isAnimating;

    [Header("Auto-generation Settings")]
    public bool autoGeneratePositions;
    public AutoGenerateDirection direction;

    void Start() {
        if (autoGeneratePositions)
            GeneratePositions();
        _hidden = hidden;
        sideMenuTransform.anchoredPosition = (hidden) ? startPosition : endPosition;
    }

    void Update() {
        CheckState();
        if (isAnimating) UpdateAnimation();
    }

    void OnEnable() {
        if (animationDuration <= 0f) {
            Debug.LogError("Cannot have an animation duration of 0. If you want it to appear instantly, just set a really small number as the duration. 0.0166666s should do the trick (1/60 of a second).\nSee https://forum.unity.com/threads/assertion-failed-on-expression-curvet-etc.446014/ for more information.");
            animationDuration = 1f;
        }
    }

    void CheckState() {
        if (hidden != _hidden) {
            startTime = Time.time + animationDelay;
            endTime = startTime + animationDuration;
            isAnimating = true;
            _hidden = hidden;
        }
    }

    void UpdateAnimation() {
        if (Time.time < startTime) return;
        float lerpTime = (endTime - Time.time) / animationDuration;
        float animationLerp = 0f;
        animationLerp = animationCurve.Evaluate(lerpTime);
        Vector3 effectivePosition = sideMenuTransform.position;
        // Animate the menu going away.
        if (!_hidden) effectivePosition = Vector3.Lerp(endPosition, startPosition, animationLerp);
        // Animate the menu coming in.
        if (_hidden) effectivePosition = Vector3.Lerp(startPosition, endPosition, animationLerp);
        sideMenuTransform.anchoredPosition = effectivePosition;
        // Stop animating when it's done.
        if (Time.time > endTime) isAnimating = false;
    }

    public void Toggle() {
        hidden = !hidden;
    }

    public void Show() {
        hidden = false;
    }

    public void Hide() {
        hidden = true;
    }

    private void GeneratePositions() {
        float widthOffset = (screenTransform.rect.width - sideMenuTransform.rect.width) / 2;
        float heightOffset = (screenTransform.rect.height - sideMenuTransform.rect.height) / 2;
        switch (direction) {
            case AutoGenerateDirection.None:
                // Do nothing.
                break;
            case AutoGenerateDirection.Top:
                endPosition = screenTransform.anchoredPosition + (Vector2.up * heightOffset);
                startPosition = endPosition + (Vector2.up * sideMenuTransform.rect.height);
                break;
            case AutoGenerateDirection.Bottom:
                endPosition = screenTransform.anchoredPosition + (Vector2.down * heightOffset);
                startPosition = endPosition + (Vector2.down * sideMenuTransform.rect.height);
                break;
            case AutoGenerateDirection.Left:
                endPosition = screenTransform.anchoredPosition + (Vector2.left * widthOffset);
                startPosition = endPosition + (Vector2.left * sideMenuTransform.rect.width);
                break;
            case AutoGenerateDirection.Right:
                endPosition = screenTransform.anchoredPosition + (Vector2.right * widthOffset);
                startPosition = endPosition + (Vector2.right * sideMenuTransform.rect.width);
                break;
        }
    }

    public enum AutoGenerateDirection {
        None,
        Top,
        Bottom,
        Left,
        Right
    }
}
