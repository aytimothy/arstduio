using System;
using System.Collections.Generic;
using System.IO;
using UnityEngine;
using UnityEngine.Events;
using Newtonsoft.Json;

public class Logger : MonoBehaviour {
    // could always ulong it... but nah.
    public uint version {
        get { return _version; }
        private set { _version = value; }
    }
    [SerializeField]
    [EditorReadOnly]
    uint _version;
    [SerializeField]
    [EditorReadOnly]
    uint version_seen;
    public List<LogMessage> messages;

    void Awake() {
        Application.logMessageReceived += Application_logMessageReceived;
        version = 0;
    }

    private void Application_logMessageReceived(string message, string stackTrace, LogType type) {
        LogMessage newMessage = new LogMessage() {
            message = message,
            stackTrace = stackTrace,
            timestamp = DateTime.Now,
            type = type
        };
        messages.Add(newMessage);
        version++;
    }

    /// <summary>
    /// Is there an update to the log (has anything new come in)?
    /// </summary>
    /// <returns></returns>
    public bool UpdateAvaliable() {
        if (version_seen != version) {
            version_seen = version;
            return true;
        }

        return false;
    }

    public void Clear() {
#if UNITY_EDITOR
        Debug.ClearDeveloperConsole();
#endif
        messages.Clear();
        version++;
    }

    public void Save(string filePath) {
        List<string> lines = new List<string>();
        foreach (LogMessage message in messages) {
            lines.Add("[" + message.timestamp.ToString("O") + "]");
            lines.Add(message.type.ToString());
            lines.Add(message.message);
            lines.Add(message.stackTrace);
        }
        File.WriteAllLines(filePath, lines);
    }

    public void SaveFormatted(string filePath) {
        LogSaveFile logFileContents = new LogSaveFile();
        logFileContents.timestamp = DateTime.Now;
        logFileContents.deviceName = SystemInfo.deviceName;
        logFileContents.deviceSerial = "// todo.";
        logFileContents.deviceModel = SystemInfo.deviceModel;
        logFileContents.deviceUUID = SystemInfo.deviceUniqueIdentifier;
        logFileContents.timezone = TimeZone.CurrentTimeZone;
        logFileContents.os = SystemInfo.operatingSystem;
        logFileContents.platform = Application.platform;
        logFileContents.ram = FormatDataSize(SystemInfo.systemMemorySize);
        logFileContents.cpu = SystemInfo.processorType;
        logFileContents.gpu = SystemInfo.graphicsDeviceVendor + " " + SystemInfo.graphicsDeviceName;
        logFileContents.gpuMem = FormatDataSize(SystemInfo.graphicsMemorySize);
        logFileContents.mem0 = "// todo.";
        logFileContents.mem1 = "// todo.";
        logFileContents.mem2 = "// todo.";
        logFileContents.comments = "";
        logFileContents.messages = messages.ToArray();

        string logFileJson = JsonConvert.SerializeObject(logFileContents);
        File.WriteAllText(filePath, logFileJson);
    }

    public bool LoadFormatted(string filePath) {
        if (!File.Exists(filePath)) {
            Debug.LogError("Could not find a log file at: \"" + filePath + "\".");
            return false;
        }
        string logFileJson = File.ReadAllText(filePath);
        if (String.IsNullOrWhiteSpace(logFileJson)) {
            Debug.LogError("There's no text in the log file at: \"" + filePath + "\".");
            return false;
        }
        LogSaveFile logFileContents = JsonConvert.DeserializeObject<LogSaveFile>(logFileJson);
        if (logFileContents == null) {
            Debug.LogError("Invalid JSON log file found at: \"" + filePath + "\".");
            return false;
        }
        foreach (LogMessage message in logFileContents.messages)
            messages.Add(message);
        return true;
    }

    public static string FormatDataSize(int size) {
        return size.ToString();
    }
}

public class LogSaveFile {
    public DateTime timestamp;          // When was the log taken?
    public string deviceName;           // The name of the device, given by the user... Or serial number.
    public string deviceSerial;         // The serial number of the device.
    public string deviceModel;          // The model/make of the device.
    public string deviceUUID;           // UUID of the device. This is generated by Unity, and is different across installs on the same device.
    public TimeZone timezone;           // Self-explainatory.
    public string os;                   // Operating System
    public RuntimePlatform platform;    // Platform Type
    public string ram;                  // Device RAM
    public string cpu;                  // Device CPU's Model
    public string gpu;                  // Device GPU's Model
    public string gpuMem;               // GPU's memory.
    public string mem0;                 // Device's built-in storage size. On PC, this is C:\
    public string mem1;                 // Device's SD Card 1 slot size. "Empty" if none found or not supported. On PC, this is D:\
    public string mem2;                 // Device's SD Card 2 slot size. "Empty" if none found or not supported. On PC, this is E:\
    public string comments;             // Any additional comments by the user?
    public LogMessage[] messages;       // List of all messages.
}

[Serializable]
public struct LogMessage {
    public DateTime timestamp;
    public string message;
    public string stackTrace;
    public LogType type;
}

#if FALSE
public class LogMessageEvent : UnityEvent<string, string, LogType> {

}

public class LogMessageEvent2 : UnityEvent<DateTime, string, string, LogType> {

}
#endif